**AUDITORÍA PROFUNDA DEL 02/02/2026 - FALLA PERSISTENTE DE ESPACIO EN BÚSQUEDA MÓVIL**

**1. AUDITORÍA DE index.html**
- **Línea 105:** Presencia de estilo inline `margin-bottom: 0 !important` (aplicado dinámicamente o por parche previo) en `#search-wrapper`.
- **Estructura de Contenedores:** El `#search-wrapper` está fuera del flujo de resultados pero dentro de `.container`. Al activar la búsqueda, se queda un "hueco" en el flujo del documento que `.container` compensa con padding.
- **Tipo de Problema:** Control de layout mixto (inline + CSS).

**2. AUDITORÍA DE style.css (CRÍTICA)**
- **Línea 400:** `body.search-active .container { padding: 75px 20px 20px; }`.
    - **Conflicto:** El `padding-top` de 75px es estático. Si la barra de búsqueda tiene `top: 10px` y una altura de ~48px, el espacio total ocupado es ~58px. El padding de 75px impone un "espacio fantasma" de ~17px adicionales de forma obligatoria.
- **Línea 374:** `body.search-active .header-container { display: none; }`.
    - **Conflicto:** Aunque `display: none` colapsa el elemento, la regla en la línea 400 vuelve a empujar el contenido hacia abajo con un valor arbitrario.
- **Líneas 2 y 11:** `height: var(--app-height, 100%);` aplicado a `html` y `body`.
    - **Riesgo:** Si `--app-height` se calcula sobre el viewport total y no sobre el área útil sobre el teclado, el scroll del `.container` puede quedar bloqueado o inaccesible bajo el teclado.
- **Líneas 404 y 420:** Uso de `position: fixed` con valores `top: 10px` y `top: 17px`.
    - **Contradicción:** Se posiciona la barra fuera del flujo, pero se intenta reservar su espacio mediante padding en un contenedor que ahora maneja su propio scroll.

**3. AUDITORÍA DE main.js**
- **Líneas 55-57:** `setTimeout(() => { document.body.classList.remove('search-active'); }, 200);`.
    - **Tipo de Problema:** Lógica de tiempo (magic number) que puede causar saltos visuales si el teclado tarda más en cerrar o si el usuario hace clic rápido.
- **Líneas 63-86:** `handleViewportChange` se ejecuta en `resize` y `scroll` del `visualViewport`.
    - **Tipo de Problema:** JS duplicado/redundante. Si el scroll está en `.container`, el scroll del `visualViewport` puede dispararse de forma inesperada en algunos navegadores móviles (Safari), recalculando la altura innecesariamente.

**4. AUDITORÍA DE ui.js**
- **Línea 538:** `mostrarResultadosDeBusqueda` limpia el contenedor.
    - **Tipo de Problema:** No se detectan conflictos directos de layout, pero el renderizado masivo puede causar que el scroll del `.container` se resetee al tope en momentos inoportunos.

**5. AUDITORÍA DE navigation.js**
- **Línea 34:** `filtrarContenido` maneja el flujo de búsqueda.
    - **Tipo de Problema:** No hay lógica que coordine el estado del teclado con la visibilidad de los resultados, delegando todo al CSS que, como se vio en el punto 2, tiene valores contradictorios.

**CONCLUSIÓN DE AUDITORÍA:**
La causa real del "espacio fantasma" es la regla de padding estático en `style.css:400` que no está sincronizada con la altura real de la barra de búsqueda fija ni con el colapso del header. Además, existe una redundancia entre el posicionamiento `fixed` de la barra y el modelo de scroll del `.container`.
