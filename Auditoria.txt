**AUDITORÍA PROFUNDA DEL 02/02/2026 - FALLA PERSISTENTE DE ESPACIO EN BÚSQUEDA MÓVIL**

**1. AUDITORÍA DE index.html**
- **Línea 105:** Presencia de estilo inline `margin-bottom: 0 !important` (aplicado dinámicamente o por parche previo) en `#search-wrapper`.
- **Estructura de Contenedores:** El `#search-wrapper` está fuera del flujo de resultados pero dentro de `.container`. Al activar la búsqueda, se queda un "hueco" en el flujo del documento que `.container` compensa con padding.
- **Tipo de Problema:** Control de layout mixto (inline + CSS).

**2. AUDITORÍA DE style.css (CRÍTICA)**
- **Línea 400:** `body.search-active .container { padding: 75px 20px 20px; }`.
    - **Conflicto:** El `padding-top` de 75px es estático. Si la barra de búsqueda tiene `top: 10px` y una altura de ~48px, el espacio total ocupado es ~58px. El padding de 75px impone un "espacio fantasma" de ~17px adicionales de forma obligatoria.
- **Línea 374:** `body.search-active .header-container { display: none; }`.
    - **Conflicto:** Aunque `display: none` colapsa el elemento, la regla en la línea 400 vuelve a empujar el contenido hacia abajo con un valor arbitrario.
- **Líneas 2 y 11:** `height: var(--app-height, 100%);` aplicado a `html` y `body`.
    - **Riesgo:** Si `--app-height` se calcula sobre el viewport total y no sobre el área útil sobre el teclado, el scroll del `.container` puede quedar bloqueado o inaccesible bajo el teclado.
- **Líneas 404 y 420:** Uso de `position: fixed` con valores `top: 10px` y `top: 17px`.
    - **Contradicción:** Se posiciona la barra fuera del flujo, pero se intenta reservar su espacio mediante padding en un contenedor que ahora maneja su propio scroll.

**3. AUDITORÍA DE main.js**
- **Líneas 55-57:** `setTimeout(() => { document.body.classList.remove('search-active'); }, 200);`.
    - **Tipo de Problema:** Lógica de tiempo (magic number) que puede causar saltos visuales si el teclado tarda más en cerrar o si el usuario hace clic rápido.
- **Líneas 63-86:** `handleViewportChange` se ejecuta en `resize` y `scroll` del `visualViewport`.
    - **Tipo de Problema:** JS duplicado/redundante. Si el scroll está en `.container`, el scroll del `visualViewport` puede dispararse de forma inesperada en algunos navegadores móviles (Safari), recalculando la altura innecesariamente.

**4. AUDITORÍA DE ui.js**
- **Línea 538:** `mostrarResultadosDeBusqueda` limpia el contenedor.
    - **Tipo de Problema:** No se detectan conflictos directos de layout, pero el renderizado masivo puede causar que el scroll del `.container` se resetee al tope en momentos inoportunos.

**5. AUDITORÍA DE navigation.js**
- **Línea 34:** `filtrarContenido` maneja el flujo de búsqueda.
    - **Tipo de Problema:** No hay lógica que coordine el estado del teclado con la visibilidad de los resultados, delegando todo al CSS que, como se vio en el punto 2, tiene valores contradictorios.

**CONCLUSIÓN DE AUDITORÍA:**
La causa real del "espacio fantasma" es la regla de padding estático en `style.css:400` que no está sincronizada con la altura real de la barra de búsqueda fija ni con el colapso del header. Además, existe una redundancia entre el posicionamiento `fixed` de la barra y el modelo de scroll del `.container`.

**AUDITORÍA EXTREMA (02/02/2026): RECONSTRUCCIÓN DE HEADER**

**1. AUDITORÍA DE index.html**
- **Líneas 87-111:** Fragmentación del encabezado en múltiples divs (`header-container`, `search-wrapper`).
- **Hallazgo:** El `#install-button` y `#search-wrapper` están fuera de `.header-container`, lo que dificulta el control unificado de visibilidad.
- **Hallazgo:** El botón de hamburguesa (`#hamburger-btn`) está anidado dentro de `#search-wrapper`, lo que vincula su layout al buscador de forma innecesaria.
- **Riesgo:** Estilos inline como `margin-bottom: 0 !important` en la línea 105 son parches de fragilidad estructural.

**2. AUDITORÍA DE style.css (CRÍTICA)**
- **Líneas 76-135:** Reglas dispersas para `.header-container` y sus hijos con múltiples media queries que redefinen `flex-direction`.
- **Líneas 374-430:** El bloque `body.search-active` intenta forzar un nuevo layout mediante `position: fixed` en elementos que antes eran `relative`, causando saltos visuales y huecos.
- **Hallazgo:** `.container` (Línea 50) tiene un padding base de 20px que se suma al padding de 60px de `search-active`, pero el modelo de scroll en `.container` hace que este padding superior sea "scrollable", dejando un hueco al tope.

**3. AUDITORÍA DE main.js**
- **Líneas 38-56:** Gestión de eventos de búsqueda (`focus`, `blur`) que activan clases de CSS.
- **Líneas 64-85:** Lógica de `visualViewport` que inyecta variables de altura.
- **Conflicto:** La clase `search-active` se quita con un `setTimeout` de 200ms, lo cual es asíncrono y puede desincronizarse con el cierre del teclado.

**4. AUDITORÍA DE ui.js / navigation.js**
- **ui.js:159, navigation.js:19:** Dependencia directa del ID `#searchInput`.
- **Hallazgo:** No hay conflictos de lógica, pero cualquier cambio de ID en el HTML durante la reconstrucción requiere actualización inmediata aquí.

**CONCLUSIÓN DE AUDITORÍA EXTREMA:**
La fragmentación HTML del header impide una transición limpia a "modo búsqueda". Al ocultar el header original con `display: none`, el navegador recalcula el flujo de `.container`, pero la barra de búsqueda (al ser `fixed`) no rellena ese espacio de forma natural. Se requiere un contenedor maestro `.main-header` que encapsule todo lo superior.

**AUDITORÍA DE RESTAURACIÓN DE REGRESIONES (02/02/2026)**

**1. AUDITORÍA DE style.css**
- **Hallazgo (Botón Hamburguesa):** El botón `#hamburger-btn` carecía de un z-index suficiente para ser interactivo sobre el nuevo layout. Se añadió `z-index: 1500`.
- **Hallazgo (Logo en Búsqueda):** La regla `body.search-active .header-branding .app-logo` ocultaba el logo incluso cuando se intentaba posicionar con `fixed`. Se forzó visibilidad con `opacity: 1 !important` y `visibility: visible !important` en el estado fixed (Línea 408).

**2. AUDITORÍA DE main.js**
- **Hallazgo (Botón X):** La lógica para mostrar/ocultar el botón de limpieza de búsqueda (`#clear-search-btn`) mediante la clase `.has-text` no estaba implementada. Se añadió el listener en la línea 41.
- **Hallazgo (Pull-to-refresh):** El cambio de scroll del `body` al `.container` desactivó el gesto nativo del navegador. Se restauró mediante listeners de `touchstart` y `touchend` calculando el desplazamiento vertical (Línea 105).

**3. AUDITORÍA DE VERSIONAMIENTO**
- **Hallazgo:** Inconsistencias entre `index.html` (v4.9.2) y los logs. Se normalizó todo el proyecto a la versión v4.9.5.
