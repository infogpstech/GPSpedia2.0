========================================
AUDITORÍA - 22/01/2026 (CIERRE DE SESIÓN INESPERADO)
========================================

**TAREA:** Investigar cierre de sesión inesperado tras múltiples recargas de la página.

**ARCHIVOS REVISADOS:**
- main.js
- auth.js

**HALLAZgos Y ANÁLISIS DE CAUSA RAÍZ:**
1.  **Flujo de Inicialización y Validación:**
    - `main.js` (`initializeApp`): Se ejecuta en `DOMContentLoaded`. La última llamada es a `auth.checkSession()`.
    - `auth.js` (`checkSession`):
        a. Lee la sesión (`gpsepedia_session`) del `localStorage`.
        b. Si no existe, muestra la pantalla de login (correcto).
        c. Si existe, la parsea y llama a `apiValidateSession(userId, sessionToken)` para validar contra el backend.
        d. Si la validación falla, llama a `logout()`.
        e. `logout()` elimina la sesión del `localStorage`.

2.  **Hipótesis Principal: Condición de Carrera (`Race Condition`) Concurrente:**
    - **Escenario:** Múltiples recargas rápidas o la apertura de múltiples pestañas de la aplicación casi al mismo tiempo.
    - **Secuencia del Fallo:**
        1.  **Recarga 1** inicia `checkSession()`, lee un token válido del `localStorage` y envía una petición de validación al backend.
        2.  **Recarga 2** inicia `checkSession()` inmediatamente después, lee el *mismo* token válido del `localStorage` y envía una *segunda* petición de validación al backend.
        3.  **Comportamiento Inferido del Backend:** Es altamente probable que el backend, al procesar una solicitud de `apiValidateSession`, no solo valide el token sino que también genere y guarde un *nuevo* token para esa sesión, invalidando el anterior. Este es un patrón de seguridad común para prevenir ataques de repetición.
        4.  La petición de la **Recarga 2** llega al backend, que valida el token `T1`, lo invalida, y genera un nuevo token `T2`.
        5.  La petición de la **Recarga 1** llega al backend un instante después. Intenta validar el token `T1`, pero este ya ha sido invalidado por la Recarga 2. El backend responde con `{ valid: false }`.
        6.  La **Recarga 1** recibe `{ valid: false }`, interpreta que la sesión ha expirado y llama a `logout()`.
        7.  `logout()` borra la sesión del `localStorage`.
        8.  Cualquier recarga o pestaña subsecuente (`Recarga 3` o incluso la `Recarga 2` si se vuelve a recargar) encontrará el `localStorage` vacío y mostrará la pantalla de login.

**CONCLUSIÓN DE LA AUDITORÍA:**
El problema no es un error lógico simple, sino una condición de carrera causada por la validación concurrente de un mismo token de sesión que es invalidado y regenerado por el backend en cada llamada. El frontend no está diseñado para manejar este escenario, asumiendo que el `localStorage` es una fuente de verdad única y que su propia validación no interferirá con otras.

**ACCIÓN REQUERIDA (PROPUESTA):**
La solución ideal es implementar un mecanismo de "bloqueo" o "mutex" en el cliente para asegurar que solo una pestaña o proceso de validación se ejecute a la vez.

1.  **Introducir un "Lock" en `localStorage`:**
    - Antes de iniciar la llamada a `apiValidateSession`, el script debería establecer una marca de tiempo de "bloqueo" en `localStorage` (ej. `session_validation_lock`).
    - Otras pestañas o recargas que se inicien comprobarían la existencia y la antigüedad de esta marca. Si el bloqueo es reciente (ej. menos de 5 segundos), la nueva instancia debería esperar y reintentar, en lugar de iniciar su propia validación.
2.  **Instrumentación con Logs:** Antes de implementar la solución, se añadirán logs de diagnóstico detallados en `auth.js` para confirmar esta hipótesis, registrando el inicio de la validación, el resultado y el momento en que se llama a `logout`.
========================================
AUDITORÍA - 22/01/2026 (RE-AUDITORÍA DE REGRESIÓN)
========================================

**TAREA:** Corrección definitiva de la regresión en el botón "Regresar" del flujo de búsqueda.

**ARCHIVOS REVISADOS:**
- ui.js

**HALLAZgos (CAUSA RAÍZ DEFINITIVA):**
1.  **Error de Lógica en `regresarABusqueda`:**
    - La auditoría anterior fue incorrecta al asumir que el problema era la existencia de un botón "Regresar" en la vista de resultados. El problema real yace en la lógica de la función `regresarABusqueda`, que se invoca correctamente pero falla en su ejecución.
    - **Línea 480:** La condición `if (navigationState && navigationState.level === 'busqueda' && navigationState.query)` es **incorrecta**.
    - **Análisis:** Cuando el usuario está en la pantalla de "Años" (invocada por `mostrarVersiones`), el `navigationState` actual tiene un `level` de `"versiones"`. El estado de la búsqueda (`{level: 'busqueda', query: '...'}`) está anidado dentro de `navigationState.previousState`.
    - **Impacto:** La condición siempre evalúa a `false` porque `navigationState.level` no es `'busqueda'`. Como resultado, la función ejecuta la lógica del bloque `else`, que incorrectamente llama a `window.navigation.irAPaginaPrincipal()`, devolviendo al usuario al inicio del catálogo en lugar de a sus resultados de búsqueda.

**CONCLUSIÓN DE LA AUDITORÍA:**
La causa raíz ha sido identificada de manera concluyente. La corrección debe realizarse exclusivamente en la función `regresarABusqueda` dentro de `ui.js`. La lógica debe ser modificada para que inspeccione el objeto `navigationState.previousState` para verificar el nivel y obtener el término de búsqueda, en lugar de inspeccionar el objeto `navigationState` de nivel superior.
========================================
AUDITORÍA - 22/01/2026 (REGRESIÓN EN BOTÓN "REGRESAR")
========================================

**TAREA:** Corrección de la regresión en el botón "Regresar" del flujo de búsqueda.

**ARCHIVOS REVISADOS:**
- ui.js
- navigation.js

**HALLAZgos:**
1.  **Causa Raíz del Comportamiento Incorrecto en `ui.js`:**
    - Se ha localizado el origen del bug en la función `mostrarResultadosDeBusqueda`.
    - **Problema Específico:** La función está construyendo y mostrando un botón "Regresar" en la propia vista de resultados de búsqueda. La acción de este botón es `window.navigation.irAPaginaPrincipal()`.
    - **Impacto:** Esto viola el flujo de navegación requerido. La página de resultados de búsqueda debe ser el nivel superior en el contexto de una búsqueda, y por lo tanto, **no debe contener un botón "Regresar"**. El botón que se muestra es el que debería aparecer en las pantallas *siguientes* del flujo para poder volver a la lista de resultados. La presencia de este botón en la vista de resultados es la causa de la confusión y el comportamiento incorrecto reportado por el usuario.

2.  **Validación de Lógica Existente:**
    - La lógica implementada en la `v4.7.8` para regresar *a* la búsqueda desde pantallas más profundas (como `mostrarVersiones`) es correcta. Las funciones `regresarABusqueda` en `ui.js` y el almacenamiento del `query` en el `navigationState` en `navigation.js` están funcionando como se espera. El problema no es cómo se regresa, sino el estado inicial de la página de resultados.

**CONCLUSIÓN DE LA AUDITORÍA:**
La solución es puntual y precisa. Se debe modificar la función `mostrarResultadosDeBusqueda` en `ui.js` para eliminar la línea de código que crea el botón "Regresar". Esto establecerá la página de resultados de búsqueda como el punto de partida correcto del flujo, permitiendo que la lógica de "Regresar" ya implementada en las pantallas subsecuentes funcione como se espera.
========================================
AUDITORÍA - 21/01/2026
========================================

**TAREA:** Consistencia del botón "Regresar" en la búsqueda de modelos.

**ARCHIVOS REVISADOS:**
- ui.js
- navigation.js

**HALLAZgos:**
1.  **Causa Raíz del Bug en el Flujo de Regreso:**
    - El problema se origina por una gestión de estado incompleta durante el proceso de búsqueda.
    - **En `navigation.js` (`filtrarContenido`):** Al realizar una búsqueda, la función establece el estado de navegación a `{ level: "busqueda" }`, pero omite guardar el término de búsqueda (`textoBusqueda`) en dicho estado.
    - **En `ui.js` (`mostrarVersiones`):** Cuando se navega a la pantalla de selección de año desde un resultado de búsqueda, el `previousState.level` es "busqueda". La lógica que construye el botón "Regresar" no tiene un caso para manejar "busqueda".
    - **Comportamiento Incorrecto:** Al no encontrar una coincidencia para el estado anterior, la función aplica un `fallback` incorrecto, generando un botón que regresa a la lista de modelos de la marca (`mostrarModelos`), en lugar de volver a los resultados de la búsqueda.

**CONCLUSIÓN DE LA AUDITORÍA:**
Para corregir el bug, se requiere un enfoque de dos partes:
1.  **Modificar `navigation.js`:** Actualizar la función `filtrarContenido` para que almacene el término de búsqueda en el `navigationState` (ej. `{ level: "busqueda", query: textoBusqueda }`).
2.  **Modificar `ui.js`:**
    - Crear una nueva función, `regresarABusqueda`, que use el `query` guardado en el estado para volver a ejecutar `filtrarContenido` y mostrar los resultados de búsqueda.
    - Actualizar la lógica del botón "Regresar" en `mostrarVersiones` para que, si `previousState.level` es "busqueda", llame a la nueva función `regresarABusqueda`.
========================================
AUDITORÍA - 20/01/2026 (REGRESIÓN CRÍTICA)
========================================

**TAREA:** Corrección de `Uncaught SyntaxError` que impide la carga de la aplicación.

**ARCHIVOS REVISADOS:**
- ui.js

**HALLAZgos:**
1.  **Causa Raíz del Error de Sintaxis:**
    - Se ha localizado un `SyntaxError` fatal en la función `mostrarResultadosDeBusqueda` del archivo `ui.js`.
    - **Línea Afectada:** 601.
    - **Problema Específico:** Durante la modificación anterior, la propiedad de un objeto fue dividida incorrectamente en dos líneas:
      ```javascript
      img.src = getImageUrl(ejemplo.imagenVehic
      ulo);
      ```
    - **Impacto:** Este error de sintaxis impide que el motor de JavaScript parsee el archivo `ui.js`, deteniendo por completo la ejecución de todos los scripts de la aplicación. Como resultado, la aplicación no puede inicializarse y se queda congelada en la pantalla de carga (splash screen).

**CONCLUSIÓN DE LA AUDITORÍA:**
El error es crítico pero de solución directa. Se debe corregir la línea 601 para que lea `ejemplo.imagenVehiculo`. Esto restaurará la capacidad de la aplicación para cargar y funcionar normalmente.
========================================
AUDITORÍA - 20/01/2026
========================================

**TAREA:** Corrección del flujo de navegación en la búsqueda de modelos.

**ARCHIVOS REVISADOS:**
- ui.js
- navigation.js

**HALLAZgos:**
1.  **Error de Lógica en `ui.js` - `mostrarResultadosDeBusqueda`:**
    - Se ha identificado que la función `mostrarResultadosDeBusqueda` es la fuente del comportamiento anómalo.
    - **Problema Específico:** Cuando los resultados de una búsqueda corresponden a un modelo, la función renderiza incorrectamente una tarjeta individual para cada AÑO disponible de ese modelo (ej. 'CR-V 2018', 'CR-V 2019'). El comportamiento esperado es que se muestren las VERSIONES DE EQUIPAMIENTO o los TIPOS DE ENCENDIDO para el modelo buscado.
    - **Causa de la Confusión:** El evento `onclick` de cada una de estas tarjetas de "año" llama a `navegarADetallesDeModelo`. Esta función está diseñada para iniciar el flujo de navegación para un modelo desde el principio, por lo que, al ser invocada, muestra la pantalla de selección de "Versión de Equipamiento", dando la impresión de que el flujo retrocede.

2.  **Análisis de `navigation.js`:**
    - La lógica de filtrado en `navigation.js` (`filtrarContenido`) funciona correctamente. Entrega la lista completa de vehículos coincidentes a `ui.js`.
    - El problema no reside en la obtención de datos, sino exclusivamente en su presentación y en la acción `onclick` asignada en la capa de UI.

**CONCLUSIÓN DE LA AUDITORÍA:**
El bug está localizado en la función `mostrarResultadosDeBusqueda` de `ui.js`. La corrección debe centrarse en modificar el `onclick` de las tarjetas de resultado de tipo "modelo" para que invoque la función de navegación correcta (`navegarADetallesDeModelo`), que ya contiene la lógica para decidir si mostrar versiones de equipamiento, tipos de encendido o directamente los años. Esto alineará el comportamiento de la búsqueda con el flujo de navegación estándar de la aplicación.

--------------------------------------------------
**FECHA:** 2024-08-01

**AUDITOR:**
Jules

**ARCHIVOS AUDITADOS:**
- `style.css`
- `index.html`
- `ui.js`
- `main.js`
- `navigation.js`

**HALLAZGOS:**

1.  **Archivo: `style.css`**
    *   **Líneas 371-387 (`body.search-active` rules):** La animación para ocultar elementos durante la búsqueda activa es abrupta. Utiliza propiedades como `max-height: 0` y `!important` que colapsan el layout de forma instantánea en lugar de permitir una transición suave. Esto causa que los botones de sección interfieran visualmente con la barra de búsqueda antes de desaparecer.
    *   **Líneas 166 (`.search-container`) y 105 (inline style en `index.html`):** Se identificó un exceso de espacio vertical alrededor de la barra de búsqueda debido a `margin-bottom: 30px` y `padding: 10px 0` en `.search-container`, además de un `margin-bottom: 20px` en el elemento `#search-wrapper` en `index.html`. Estos valores combinados reducen el espacio disponible para los resultados de búsqueda.
    *   **Líneas 371-387 (`body.search-active` rules):** El botón de hamburguesa (`#hamburger-btn`) es afectado por las mismas reglas de animación abruptas que los botones de sección, provocando que no se oculte de forma consistente o suave.

2.  **Archivo: `ui.js`**
    *   **Línea 1045 (`createAccordionSection` function):** La lógica para la "Vídeo Guía de Desarme" actualmente solo genera un enlace (`<a>`) a la URL del video. No hay un reproductor de video embebido, lo cual es necesario para cumplir con los requisitos.
    *   **Línea 1061 (`btn.addEventListener`):** El listener del acordeón no tiene lógica para controlar la reproducción de video. Si se implementa un iframe, es necesario añadir aquí la funcionalidad para pausar el video cuando el acordeón se colapsa.
    *   **Línea 650 (`mostrarDetalleModal` function):** El botón para cerrar el modal de detalle no tiene funcionalidad para detener un video que se esté reproduciendo. Si se añade un video, este continuará reproduciéndose en segundo plano después de cerrar el modal si no se implementa una lógica de detención.

3.  **Archivo: `index.html`**
    *   **Línea 105 (`#search-wrapper`):** El `margin-bottom: 20px` contribuye al exceso de espaciado vertical identificado en la auditoría de `style.css`.
--------------------------------------------------
**FECHA:** 2024-08-02 (Post-Commit Review)

**AUDITOR:**
Jules

**ARCHIVOS AUDITADOS:**
- `style.css`
- `ui.js`

**HALLAZGOS (Post-Commit):**

1.  **Archivo: `style.css`**
    *   **Línea 390 (`body.search-active .container`):** Se ha identificado la causa del espaciado incorrecto. Cuando la barra de búsqueda se vuelve `position: fixed`, el `.container` principal no tiene un `padding-top` para compensar la altura de la barra. Esto hace que el contenido (`#contenido`) se posicione en la parte superior del viewport, quedando oculto detrás de la barra de búsqueda. La eliminación del `padding-top` en el commit anterior fue la causa directa de esta regresión visual.

2.  **Archivo: `ui.js`**
    *   **Línea 1061 (`btn.addEventListener`):** Se ha identificado una regresión funcional en el acordeón. La lógica del `event listener` fue modificada para manejar la pausa del video, pero esta modificación alteró el comportamiento original. La animación de `max-height` ahora no funciona correctamente porque la lógica de pausa interfiere con el cálculo del `scrollHeight`.
    *   **Línea 1045 (`createAccordionSection` function):** El `iframe` del video se crea correctamente, pero no es visible dentro del modal. Esto se debe a que el panel del acordeón (`panel-desplegable`) tiene `max-height: 0` y `overflow: hidden` por defecto, y la nueva lógica no está expandiendo el panel correctamente para hacer visible el video. La solución requiere restaurar la lógica original del acordeón y asegurar que el video se renderice dentro de un panel que pueda expandirse.
--------------------------------------------------
========================================
AUDITORÍA - 2024-08-03 (REINICIO POST-COMMIT)
========================================

**TAREA:** Corrección de fracasos funcionales y regresiones graves detectadas post-commit.

**ARCHIVOS REVISADOS:**
- style.css
- ui.js

**HALLAZGOS Y ANÁLISIS DE CAUSA RAÍZ:**

1.  **TAREA 2 — Espacio entre barra de búsqueda y resultados (FRACASO):**
    *   **Archivo:** `style.css`
    *   **Línea (aprox):** 453 (Regla `body.search-active .container`)
    *   **Causa Raíz:** La regla `padding-top: 60px;` aplicada al `.container` cuando la búsqueda está activa es la causa directa del espacio excesivo. Aunque se requiere un `padding-top` para evitar que el contenido quede oculto detrás de la barra de búsqueda fija, el valor de `60px` es demasiado grande y crea un espacio vertical no deseado, empeorando el problema original. La solución es ajustar este valor a uno que compense la altura de la barra de búsqueda de manera más precisa.

2.  **SUBTAREA 4.1 — Regresión en Lógica de Acordeón (FRACASO):**
    *   **Archivo:** `ui.js`
    *   **Línea (aprox):** 1313 (dentro de `createAccordionSection`, en `btn.addEventListener`)
    *   **Causa Raíz:** La lógica actual del `event listener` del acordeón solo gestiona el estado del botón que fue clickeado (`this`). Carece por completo de la lógica para buscar y cerrar cualquier otro panel de acordeón que ya estuviera abierto. Esto viola el comportamiento original donde solo un panel podía estar abierto a la vez. Es necesario reintroducir la lógica que itera sobre todos los botones del acordeón dentro del mismo contenedor para cerrar los que no sean el actual.

3.  **SUBTAREA 4.2 — Video guía de desarme (FRACASO):**
    *   **Archivo:** `ui.js`
    *   **Línea (aprox):** 1133 (dentro de `mostrarDetalleModal`) y 1313 (`createAccordionSection`).
    *   **Causa Raíz (No visualización):** El video no se muestra porque la animación del acordeón está rota. El `event listener` modificado para pausar el video (`transitionend`) está separado de la lógica de `click`, pero la lógica de `click` en sí misma ya no calcula correctamente el `scrollHeight` del panel. Como resultado, el `max-height` del panel nunca se establece en un valor que permita que el contenido (el iframe del video) se haga visible.
    *   **Causa Raíz (Renderizado condicional):** La lógica para mostrar el botón del acordeón solo si `item.Video` existe es correcta (`if (hasContent && sec.title)`). El problema no es que el botón no se cree, sino que el panel que contiene el video nunca se expande.
    *   **Causa Raíz (Pausa/Detención):** La lógica para pausar y detener el video en `transitionend` y al cerrar el modal es conceptualmente correcta, pero es inefectiva porque el video nunca llega a mostrarse y reproducirse.

**CONCLUSIÓN DE LA AUDITORÍA:**
Los fracasos se deben a correcciones imprecisas en el commit anterior. La solución requiere:
1.  **En `style.css`:** Reducir el valor de `padding-top` en la regla `body.search-active .container`.
2.  **En `ui.js`:**
    - Restaurar la lógica original del `event listener` del acordeón para que cierre otros paneles abiertos.
    - Asegurar que el cálculo de `scrollHeight` se realice correctamente para que el panel del video pueda expandirse y hacerse visible.
    - Mantener la lógica de control del video (pausa/detención) pero asegurar que se active en el contexto de un acordeón que funcione correctamente.
========================================
AUDITORÍA - 2024-08-04 (IN-DEPTH AUDIT POST-FAILURE)
========================================

**TAREA:** Análisis de causa raíz de fallas persistentes en espaciado de búsqueda y visualización de video.

**ARCHIVOS REVISADOS:**
- style.css
- ui.js

**HALLAZGOS Y ANÁLISIS DE CAUSA RAÍZ:**

1.  **TAREA — Espacio entre barra de búsqueda y resultados (INCOMPLETA):**
    *   **Archivo:** `style.css`
    *   **Línea (aprox):** 73 (`.container`), 395 (`body.search-active .container`)
    *   **Causa Raíz (Conflicto de Especificidad / Efecto Aditivo):** El problema no es un conflicto directo, sino un efecto aditivo no considerado.
        - La regla general `.container` aplica un `padding: 20px;` en todos los lados.
        - La regla `body.search-active .container` establece `padding-top: 20px;`, pero no anula los otros paddings (left, right, bottom) definidos por la regla general.
        - **Resultado:** El `padding-top` se establece correctamente, pero el `padding-bottom: 20px` de la regla general persiste, creando un espacio total mayor al deseado y dando la impresión de que el espacio superior no se redujo lo suficiente.
    *   **Solución Propuesta:** La regla `body.search-active .container` debe ser más específica y definir todos los valores de padding para anular completamente la regla general (ej. `padding: 20px 20px 0;`).

2.  **TAREA — Video guía en modal de detalle de corte (FRACASO):**
    *   **Archivo:** `ui.js`
    *   **Línea (aprox):** 1087 (dentro de `createAccordionSection`, en `btn.addEventListener`).
    *   **Causa Raíz (Condición de Carrera - Race Condition):** El problema es una condición de carrera entre el cálculo del `scrollHeight` del panel y la carga del `iframe` del video.
        - **Secuencia del Fallo:**
            1.  El usuario hace clic en el botón del acordeón.
            2.  El `event listener` se dispara *inmediatamente*.
            3.  La línea `panel.style.maxHeight = panel.scrollHeight + "px";` se ejecuta. En este momento, el `iframe` que está dentro del `panel` aún no ha cargado su contenido (el reproductor de YouTube), por lo que su altura es `0`.
            4.  El navegador calcula el `scrollHeight` del panel basándose únicamente en el contenido de texto (si lo hay), ignorando el video que aún no tiene dimensiones.
            5.  El panel se anima a un `max-height` que es demasiado pequeño.
            6.  El `iframe` finalmente carga y renderiza el video, pero como está dentro de un contenedor con `overflow: hidden` y un `max-height` insuficiente, permanece invisible.
    *   **Solución Propuesta:** La lógica debe ser modificada para esperar a que el `iframe` haya cargado antes de calcular y aplicar el `scrollHeight`, o utilizar una técnica alternativa que no dependa del `scrollHeight` inicial, como usar Flexbox o un `max-height` suficientemente grande y fijo. La solución más robusta es desacoplar la animación de la carga del contenido.

**CONCLUSIÓN DE LA AUDITORÍA PROFUNDA:**
Se han identificado las causas raíz definitivas. El problema del espaciado es un efecto aditivo de CSS, y el del video es una condición de carrera clásica en el manejo de iframes. Las correcciones deben abordar estos problemas específicos.
========================================
AUDITORÍA - 2024-08-05 (AUDITORÍA EXCLUSIVA DE BACKEND)
========================================

**TAREA:** Verificar la correcta entrega del campo de la video guía desde el backend.

**ARCHIVOS REVISADOS:**
- Code.gs

**HALLAZGOS Y ANÁLISIS DE CAUSA RAÍZ:**

1.  **Análisis de `Code.gs`:**
    *   **Hallazgo Crítico:** El archivo `Code.gs` es un servicio **legacy** post-migración. Su única y exclusiva funcionalidad actual es la de actuar como un receptor de logs (`logFrontend`).
    *   **Evidencia Concluyente:** El código no contiene ninguna función, endpoint o lógica relacionada con la obtención o el envío de datos del catálogo (hoja "CORTES"). La estructura `switch` en la función `doPost` maneja únicamente la acción `logFrontend` y lanza un error explícito para cualquier otra acción, confirmando que la obtención de datos fue migrada a otro servicio.

**CONCLUSIÓN DE LA AUDITORÍA DE BACKEND:**
La auditoría del backend es concluyente: **el archivo `Code.gs` no es la fuente de los datos del catálogo y no tiene ninguna relación con el bug de la video guía.** La sospecha de que el backend estaba fallando es incorrecta.

Este hallazgo refuerza la conclusión de la auditoría anterior: el problema reside exclusivamente en el frontend, específicamente en la condición de carrera (`race condition`) dentro del `event listener` del acordeón en `ui.js`.
========================================
AUDITORÍA - 2024-08-06 (AUDITORÍA CORRECTIVA Y CONSOLIDADA)
========================================

**TAREA:** Identificar las causas raíz definitivas de los fallos persistentes tras la corrección de un error de auditoría previo.

**ARCHIVOS REVISADOS:**
- README.md
- services/catalog/catalog.js
- index.html
- style.css
- ui.js

**HALLAZGOS Y ANÁLISIS DE CAUSA RAÍZ CONSOLIDADOS:**

1.  **Causa Raíz - Video Guía No se Visualiza (Backend + Frontend Mismatch):**
    *   **Archivo Backend:** `services/catalog/catalog.js`
    *   **Línea (aprox):** 281-310 (dentro de `handleGetCatalogData`).
    *   **Análisis:** La auditoría del backend correcto (`catalog.js`) revela que el servicio lee correctamente la columna `videoGuiaDesarmeUrl` de la base de datos. Sin embargo, el objeto `vehicle` que se construye y se envía al frontend **mantiene el nombre de la propiedad como `videoGuiaDesarmeUrl`**.
    *   **Archivo Frontend:** `ui.js`
    *   **Línea (aprox):** 818 (dentro de `mostrarDetalleModal`).
    *   **Análisis:** La lógica del frontend que construye las secciones del acordeón espera una propiedad llamada `videoUrl` (basado en la línea `videoUrl: item.Video`). Existe una inconsistencia adicional, ya que el código anterior esperaba `item.Video` (con 'V' mayúscula).
    *   **Causa Raíz Conclusiva:** El problema es una **discrepancia en el contrato de datos** entre el backend y el frontend. El backend envía `videoGuiaDesarmeUrl`, mientras que el frontend espera `Video` o `videoUrl`. Como resultado, la condición `if (sec.videoUrl)` siempre es falsa, y la sección del acordeón del video nunca se crea.

2.  **Causa Raíz - Espacio Incorrecto en Barra de Búsqueda (Especificidad CSS):**
    *   **Archivo:** `index.html`
    *   **Línea (aprox):** 111.
    *   **Análisis:** La auditoría del HTML confirma la existencia de un `div` con `id="search-wrapper"` que tiene un estilo en línea: `style="...; margin-bottom: 10px;"`.
    *   **Archivo:** `style.css`
    *   **Análisis:** Debido a la alta especificidad de los estilos en línea, las reglas existentes en `style.css` para el estado `body.search-active` no son capaces de anular este `margin-bottom`.
    *   **Causa Raíz Conclusiva:** El `margin-bottom` en línea del `div#search-wrapper` es la causa directa y única del espacio persistente. La solución requiere una regla de CSS con la especificidad suficiente para anularlo (ej. `body.search-active #search-wrapper`).

**CONCLUSIÓN DE LA AUDITORÍA CONSOLIDADA:**
Se han identificado las dos causas raíz definitivas y no relacionadas:
1.  Un **contrato de datos roto** entre el microservicio `catalog.js` y el `ui.js` impide que se muestre el video.
2.  Un **estilo en línea con alta especificidad** en `index.html` causa el problema de espaciado visual.

Ambos problemas son ahora claramente entendidos y pueden ser corregidos de forma precisa.
========================================
AUDITORÍA - 2024-08-07 (AUDITORÍA FINAL DE CAUSA RAÍZ)
========================================

**TAREA:** Análisis definitivo de las causas raíz de los problemas persistentes del video y el espaciado.

**ARCHIVOS REVISADOS:**
- ui.js
- index.html

**HALLAZGOS Y ANÁLISIS DE CAUSA RAÍZ:**

1.  **Causa Raíz - Video No se Reproduce (Construcción de URL Embed):**
    *   **Archivo:** `ui.js`
    *   **Línea (aprox):** 1049 (dentro de `createAccordionSection`).
    *   **Análisis:** La lógica para construir la URL del `iframe` es demasiado simple y frágil. La línea `sec.Video.replace("watch?v=", "embed/")` solo funciona para un formato de URL de YouTube específico. No maneja otros formatos válidos como `youtu.be/VIDEO_ID` o URLs que ya están en formato `embed`.
    *   **Causa Raíz Conclusiva:** El frontend no está convirtiendo de manera robusta todas las posibles URLs de YouTube a un formato `embed` válido, lo que provoca que el `iframe` no pueda cargar el video.

2.  **Causa Raíz - Espacio en Barra de Búsqueda (Estilo en Línea):**
    *   **Archivo:** `index.html`
    *   **Línea (aprox):** 111.
    *   **Análisis:** Se confirma que el `div` con `id="search-wrapper"` tiene un estilo en línea que incluye `margin-bottom: 10px;`. Este estilo, debido a su alta especificidad, no es anulado por las reglas generales en `style.css`.
    *   **Causa Raíz Conclusiva:** El estilo en línea es la causa directa del espaciado no deseado. La solución requiere una regla en `style.css` con la especificidad suficiente para anular este estilo en línea durante el estado de búsqueda activa.

**CONCLUSIÓN DE LA AUDITORÍA FINAL:**
Las causas raíz han sido definitivamente identificadas y aisladas en el frontend. La corrección del video requiere una función de parseo de URL más robusta en `ui.js`, y la corrección del espaciado requiere una regla de CSS más específica.
