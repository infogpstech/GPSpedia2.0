**v5.0.5 (DD/MM/YYYY)**
*   **FIX (services/catalog/catalog.js):** Corregido un bug crítico que causaba un crash silencioso en el backend si alguna de las hojas de datos (`Cortes`, `LogosMarca`, etc.) no existía.
    *   **Causa Raíz:** El servicio intentaba leer datos de las hojas sin verificar primero su existencia, provocando un error `TypeError: Cannot read properties of null` que detenía la ejecución y enviaba una respuesta de error genérica al frontend.
    *   **Solución:** Se ha añadido una comprobación de existencia para cada hoja. Si una hoja no se encuentra, el servicio ahora registra un error en la consola y devuelve un array vacío para esa sección de datos, en lugar de fallar. Esto asegura que el frontend siempre reciba una respuesta válida y previene el error "Fallo de conexión". (Líneas 194-266).
*   **FIX (index.html):** Mejorada la lógica de manejo de errores de sesión para prevenir cierres de sesión incorrectos.
    *   **Causa Raíz:** La función `checkSession` trataba cualquier error durante la inicialización de la aplicación (incluyendo el fallo de carga del catálogo) como un error de sesión no válida, cerrando la sesión del usuario de forma incorrecta.
    *   **Solución:** Se ha refactorizado la lógica. Ahora, si la validación de la sesión es exitosa pero la carga de datos del catálogo falla, la aplicación permanecerá autenticada y mostrará un mensaje de error claro al usuario, en lugar de redirigirlo a la pantalla de login. El cierre de sesión solo ocurrirá si la validación de la sesión falla explícitamente. (Líneas 1603-1623).

**v5.0.4 (DD/MM/YYYY)**
*   **REWRITE (service-worker.js):** Reescritura completa del Service Worker con una arquitectura de caché multi-estrategia para resolver definitivamente el problema de pérdida de sesión.
    *   **Causa Raíz:** El Service Worker anterior trataba todas las peticiones de red por igual, cacheando indebidamente las respuestas de la API de autenticación. Esto provocaba que se sirvieran datos de sesión obsoletos desde el caché, resultando en la pérdida de sesión al recargar la página.
    *   **Solución:** Se ha implementado un `fetch handler` inteligente que aplica una estrategia de caché diferente según el tipo de recurso:
        1.  **Peticiones de Autenticación:** Si la petición es al microservicio `AUTH`, se ignora el caché y la petición va **siempre a la red**. Esto garantiza que la validación de la sesión sea siempre en tiempo real.
        2.  **Otras Peticiones API (Datos):** Para los demás microservicios, se usa una estrategia "Network falling back to Cache". La app intenta obtener datos frescos, pero si no hay red, muestra los últimos datos guardados.
        3.  **Assets Estáticos (App Shell):** Para los archivos de la aplicación (HTML, CSS, etc.), se usa "Cache First" para una carga instantánea.
    *   **Se ha incrementado la versión del caché a `v8`** para asegurar que todos los usuarios reciban y activen el nuevo Service Worker de inmediato.

**v5.0.3 (DD/MM/YYYY)**
*   **REWRITE (service-worker.js):** Reescritura completa del Service Worker para corregir un fallo crítico de caché que causaba la pérdida de sesión.
    *   **Causa Raíz:** La estrategia de caché "network-first" anterior interceptaba y almacenaba en caché **todas** las respuestas de red, incluidas las llamadas a la API (ej. `validateSession`). Si la red fallaba en un re-load, el Service Worker servía una respuesta de `validateSession` obsoleta desde el caché, lo que provocaba que la aplicación cerrara la sesión del usuario incorrectamente.
    *   **Solución:** Se ha reescrito el `fetch handler` con una nueva lógica:
        1.  **Detecta las llamadas a la API:** Si la URL del `request` apunta al backend de Google Apps Script, la petición se envía **directamente a la red**, ignorando por completo el caché. Esto garantiza que las comprobaciones de sesión siempre sean en tiempo real.
        2.  **Mantiene el caché para assets:** Para todas las demás peticiones (HTML, CSS, imágenes), se mantiene la estrategia "network falling back to cache", conservando la capacidad offline de la aplicación.
    *   **Se ha incrementado la versión del caché a `v7`** para forzar a todos los clientes a actualizar y adoptar el nuevo Service Worker inmediatamente.

**v5.0.2 (DD/MM/YYYY)**
*   **FIX (index.html):** Corregido un bug crítico de persistencia de sesión que causaba que la sesión se perdiera al recargar la página.
    *   **Causa Raíz:** Se identificó una condición de carrera en la función `hideLoginShowApp`. Esta función ignoraba el objeto de usuario ya validado que recibía como parámetro y, en su lugar, volvía a leer los datos de sesión desde `localStorage`. Esta segunda lectura era innecesaria y propensa a fallos.
    *   **Solución:** Se ha refactorizado la función `hideLoginShowApp` para que utilice exclusivamente el objeto `user` que se le pasa como parámetro. Esto elimina la lectura redundante de `localStorage`, cierra la condición de carrera y asegura que la sesión se mantenga de forma robusta y predecible después de recargar la página. (Líneas 1764-1775).

**v5.0.1 (DD/MM/YYYY)**
*   **INFRA (api-manager.js):** Actualizada la URL del microservicio `AUTH` a su nueva versión desplegada.
    *   Se ha reemplazado la URL en el objeto `API_ENDPOINTS` para `AUTH` para apuntar al nuevo despliegue que contiene la lógica de sesión reescrita y estabilizada. (Línea 10).

**v5.0.0 (DD/MM/YYYY)**
*   **REWRITE (services/auth/auth.js):** Reescritura completa del servicio de autenticación desde cero para máxima estabilidad.
    *   **Causa Raíz:** La lógica anterior de gestión de múltiples sesiones era compleja y propensa a errores, causando condiciones de carrera y fallos de sesión impredecibles.
    *   **Solución:** Se ha implementado un nuevo modelo de **sesión única**. Al iniciar sesión, el sistema ahora invalida y elimina todas las sesiones antiguas de ese usuario antes de crear una única sesión nueva y válida. Esta estrategia elimina toda la complejidad anterior y asegura que solo exista un estado de sesión válido por usuario en un momento dado.
    *   **Mejoras Adicionales:** El código ha sido refactorizado con funciones auxiliares para mayor claridad, se ha mejorado el registro de errores y se ha reforzado el manejo de casos excepcionales (ej. hojas de cálculo faltantes). (Reescritura completa del archivo).
